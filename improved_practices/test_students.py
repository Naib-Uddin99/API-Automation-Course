import requests
import pytest
from pprint import pformat
import time



def test_get_all_students_api(api_config):

    base_url = api_config['BASE_URL']
    api_endpoint = api_config['API_ENDPOINT']
    required_schema = api_config['REQUIRED_SCHEMA']
    optional_schema = api_config['OPTIONAL_SCHEMA']

    # Send GET request (using -1 pageSize for maximum data)
    params = {"pageSize": -1}
    response = requests.get(f"{base_url}{api_endpoint}",params=params)

    # 1. Validate response status code
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"

    json_response = response.json()
    assert isinstance(json_response, list), "Expected a list of students."
    print(json_response)

    # 2. Validate schema for the first 5 students (or all if < 5)
    for student in json_response[:5]:
        student_name = student.get("name", "Unknown")
        actual_keys = set(student.keys())

        # Validate that all required keys are present ← New validation logic
        required_keys = set(required_schema.keys())
        missing_required_keys = required_keys - actual_keys
        assert not missing_required_keys, (
            f"❌ Missing required keys for user '{student_name}'.\n"
            f"Missing: {missing_required_keys}\n"
            f"Required keys: {pformat(required_keys)}\n"
            f"Actual keys: {pformat(actual_keys)}"
        )

        # Validate data types for required fields
        for key, expected_type in required_schema.items():
            actual_value = student.get(key)
            assert isinstance(actual_value, expected_type), (
                f"❌ Invalid type for required field '{key}' in user '{student_name}'. "
                f"Expected {expected_type.__name__}, got {type(actual_value).__name__}"
            )

        # Validate data types for optional fields (if present)
        for key, expected_type in optional_schema.items():
            if key in student:  # Only validate if the field is present
                actual_value = student.get(key)
                assert isinstance(actual_value, expected_type), (
                    f"❌ Invalid type for optional field '{key}' in user '{student_name}'. "
                    f"Expected {expected_type.__name__}, got {type(actual_value).__name__}"
                )


def test_get_student_by_registration_id(api_config, created_student_id, student_data):
    """Tests retrieval of a specific student using registrationId parameter."""

    base_url = api_config['BASE_URL']
    api_endpoint = api_config['API_ENDPOINT']

    # Use search by registrationId parameter
    params = {"registrationId": student_data['registrationId']}
    time.sleep(1)  # Small delay to ensure student is available
    response = requests.get(f"{base_url}{api_endpoint}", params=params)

    # Validate status code
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"

    # Validate that we found exactly one student
    students = response.json()
    assert len(
        students) == 1, f"Expected 1 student with registrationId '{student_data['registrationId']}', found {len(students)}"

    actual_student = students[0]

    # Validate that the returned student has the correct ID
    assert actual_student.get('_id') == created_student_id, (
        f"Student ID mismatch. Expected: {created_student_id}, Got: {actual_student.get('_id')}"
    )

    # Validate data integrity - check that fetched data matches the original data
    for key, value in student_data.items():
        if key != "_id":  # Exclude _id since it's generated by the system
            assert actual_student.get(key) == value, (
                f"Data mismatch for key '{key}'. Expected: {value}, Got: {actual_student.get(key)}"
            )

    # Validate that the student has all required fields using our schema
    required_schema = api_config['REQUIRED_SCHEMA']
    optional_schema = api_config['OPTIONAL_SCHEMA']

    # Check required fields are present and have correct types
    for key, expected_type in required_schema.items():
        assert key in actual_student, f"Required field '{key}' missing from student data"
        actual_value = actual_student.get(key)
        assert isinstance(actual_value, expected_type), (
            f"Invalid type for required field '{key}'. "
            f"Expected {expected_type.__name__}, got {type(actual_value).__name__}"
        )

    # Check optional fields have correct types (if present)
    for key, expected_type in optional_schema.items():
        if key in actual_student:
            actual_value = actual_student.get(key)
            assert isinstance(actual_value, expected_type), (
                f"Invalid type for optional field '{key}'. "
                f"Expected {expected_type.__name__}, got {type(actual_value).__name__}"
            )

    print(f"\n✅ Student retrieval by registrationId '{student_data['registrationId']}' validated successfully.")
    print(f"✅ Student ID: {actual_student.get('_id')}")
    print(f"✅ Student Name: {actual_student.get('name')}")
    print(f"✅ All data integrity checks passed.")


def test_search_students_by_name_filter(api_config, student_data):
    """
    Tests the search functionality by checking if the specific test student is found,
    and all returned names match the query (partial/case-insensitive).
    """

    base_url = api_config['BASE_URL']
    api_endpoint = api_config['API_ENDPOINT']
    search_name = student_data['name']

    # 1. Send GET request with the search parameter
    params = {"name": search_name}
    response = requests.get(f"{base_url}{api_endpoint}", params=params)

    # 2. Validate status code
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"

    response_data = response.json()

    # 3. Assert the known test student is in the list and all results match the query
    found_known_student = False
    for student in response_data:
        # Check that the name returned is a match for the search term
        student_name = student.get('name', '')
        assert search_name.lower() in student_name.lower(), \
            f"❌ Search returned name '{student_name}' which doesn't match query '{search_name}'."

        if student.get('email') == student_data['email']:
            found_known_student = True

    assert found_known_student, f"❌ Search query did not find the expected test student with name '{search_name}'."
    print(f"\n✅ Search query successfully found the specific test student and returned only matching names.")


def test_get_student_by_non_existent_id(api_config):
    """
    Tests that requesting a student with a non-existent ID returns a 404 Not Found status.
    """
    base_url = api_config['BASE_URL']
    api_endpoint = api_config['API_ENDPOINT']

    # Use a string that is highly unlikely to be a valid ID
    non_existent_id = "999999999999999999999999"

    get_url = f"{base_url}{api_endpoint}/{non_existent_id}"
    response = requests.get(get_url)

    # Assert the expected failure status code
    assert response.status_code == 404, \
        f"❌ Expected 404 Not Found for non-existent ID, but got {response.status_code}"

    print(f"\n✅ Successfully validated 404 Not Found for non-existent ID.")


def test_search_students_by_department(api_config, student_data):
    """
    Tests filtering students by the 'department' query parameter.
    Asserts that the specific test student is found, and all results match the department.
    """
    base_url = api_config['BASE_URL']
    api_endpoint = api_config['API_ENDPOINT']
    expected_department = student_data['department']  # 'Engineering' from the fixture
    expected_email = student_data['email']

    # 1. Send GET request with the department parameter
    params = {"department": expected_department}
    response = requests.get(f"{base_url}{api_endpoint}", params=params)

    # 2. Validate status code
    assert response.status_code == 200, f"Expected 200, got {response.status_code}"

    response_data = response.json()
    assert len(response_data) >= 1, f"❌ Expected at least one student, got 0 for department: {expected_department}"

    # 3. Assert all returned students are in the correct department and our fixture student is present
    found_fixture_student = False
    for student in response_data:
        actual_department = student.get('department')

        # Check that every student returned matches the filter
        assert actual_department.lower() == expected_department.lower(), \
            f"❌ Returned student is in '{actual_department}', expected '{expected_department}'."

        if student.get('email') == expected_email:
            found_fixture_student = True

    assert found_fixture_student, f"❌ Search by department did not find the specific test student with email '{expected_email}'."
    print(f"\n✅ Search query successfully filtered students by department: '{expected_department}'.")